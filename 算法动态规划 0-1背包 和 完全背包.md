# 算法动态规划 0-1背包

## 背包问题

0-1背包就是有n种物品，每种物品只有一个

其实0-1背包有一个特点，首先我们先获取当前这个背包的最大容量，然后先遍历物品，然后在遍历背包

然后我们的DP推导公式就是**dp[j] = Math.max(dp[j],dp[i-num[i]] + num[i])**

## Leetcode 416

### Ideas

由题意得出我们要将nums数组分为2个字数组，所以我们可以得知如果nums的和%2 不等于 0，那么就说明这个数组无法分割为2个字符串，

~~~java
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        
        if (sum % 2 != 0){
            return false
        }
~~~

接下来我们可以得知，因为我们的要将数组分为2个数组，那么也就是说 sum/2就是我们背包的最大容量。

```java
int target = sum/2;
int[] dp = new int[target+1];
```

接下来是用我们推导公式来进行计算dp[j] = Math.max(dp[j],dp[i-num[i]] + num[i])

~~~java
        for (int i = 0; i < n; i++) {
            //遍历背包
            for (int j = target; j >= nums[i] ; j--) {
                dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i]);
            }
        }
~~~

接下来判断dp[target] == target 如果为true就说明可以分割

~~~code
        return dp[target] == target;
~~~

### codes

~~~java
class Solution {
    public boolean canPartition(int[] nums) {
         int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        if (sum % 2 != 0){
            return false;
        }

        int target = sum/2;
        int[] dp = new int[target+1];

        int n = nums.length;
        //遍历物品
        for (int i = 0; i < n; i++) {
            //遍历背包
            for (int j = target; j >= nums[i] ; j--) {
                dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i]);
            }
        }

        return dp[target] == target;
    }
}
~~~

## Leetcode P1049

### ideas

这个题我们可以这么想，把stones的数组里，尽可能的分为2堆石头，让这2堆石头的差变得最小这样这两堆石头碰撞剩下的元素就是最小的元素。那我们就可以把这个题看作一个0-1背包问题，我们只求其中一个最小的堆重量就可以了，为什么说是最小的堆，请往下看。

首先我们0-1背包问题我们第一件事情就是找到我们最大的容量

```java
int sum = 0;
for (int stone : stones) {
    sum+=stone;
}
int target = sum/2;
int[] dp = new int[target+1];
```

刚才我们说为什么是最小的一个石头堆重量是因为在计算机的世界里sum/2 是向下取整。

接下来我我们开始递归dp

~~~java
        int n = stones.length;
        for (int i = 0; i < n; i++) {
            for (int j = target ; j >= stones[i] ; j--){
                dp[j] = Math.max(dp[j],dp[j - stones[i]] + stones[i]);
            }
        }
~~~

接下来我们我们获取最大的那堆sum - dp[target]，在减去最小的那堆,答案就是最剩下的石头

~~~java
 return (sum - dp[target]) - dp[target];
~~~

### code

~~~java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int stone : stones) {
            sum+=stone;
        }
        int target = sum/2;
        int[] dp = new int[target+1];

        int n = stones.length;
        for (int i = 0; i < n; i++) {
            for (int j = target ; j >= stones[i] ; j--){
                dp[j] = Math.max(dp[j],dp[j - stones[i]] + stones[i]);
            }
        }

        return (sum - dp[target]) - dp[target];
    }
}
~~~

## Leetcode P494

### Function DP

#### ideas

​	首先我们要找出我们最大的容量

```java
int sum = 0;
for (int num : nums) {
    sum += num;
}
int diff = sum - target;
//如果diff < 0 就代表 sum 比target小无法满足
//如果diff % 2 == 1 就代表无法满足，因为想让L - R == target 那么就必须满足 diff % 2 == 0
if (diff < 0 || diff % 2 != 0){
    return 0;
}

//获取最大容量
int size = diff /2;

int[] dp = new int[size+1];
```

接下来我们要对我们的dp数组进行初始化

~~~c++
        dp[0] = 1; //背包容量为0 有1种方法，就是不装
~~~

接下来开始遍历

```java
//遍历物品
for (int i = 0; i < nums.length; i++) {
    //遍历背包
    for (int j = size; j >= nums[i]; j--) {
        dp[j] = dp[j-nums[i]]+1;
    }
}
```

#### code

~~~java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int diff = sum - target;
        //如果diff < 0 就代表 sum 比target小无法满足
        //如果diff % 2 == 1 就代表无法满足，因为想让L - R == target 那么就必须满足 diff % 2 == 0
        if (diff < 0 || diff % 2 != 0){
            return 0;
        }

        //获取最大容量
        int size = diff /2;

        int[] dp = new int[size+1];

        dp[0] = 1; //背包容量为0 有1种方法，比如
        //遍历物品
        for (int i = 0; i < nums.length; i++) {
            //遍历背包
            for (int j = size; j >= nums[i]; j--) {
                dp[j] += dp[j-nums[i]];
            }
        }

        return dp[size];
    }
}
~~~

### Funciton DFS

该题的数据小，同样也可以使用DFS

~~~java
class Solution {
    int res =0 ;
    public int findTargetSumWays(int[] nums, int target) {
        dfs(nums, target, 0, 0);
        return res;
    }

    public void dfs(int num[],int target,int sum,int index){
        if (index == num.length){
            if (target == sum){
                res++;
                return;
            }
            return;
        }else if (index >= num.length){
            return;
        }
        
        dfs(num, target, sum+num[index], index+1);
        dfs(num, target, sum-num[index], index+1);
    }
}
~~~

## Leetocde P474

### Ideas

由题意得出，最大容量为m和n，我们直接初始化DP数组

```java
int[][] dp = new int[m+1][n+1];
```

接下来我们直接遍历就好了

~~~java
        //遍历物品
        for (String str : strs) {
            int zerounm =0;
            int onenum  =0;
            for (char c : str.toCharArray()) {
                if (c=='1') onenum++;else zerounm++;
            }

            for (int i = m; i >= zerounm ; i--) {
                for (int j = n; j >= onenum ; j--) {
                    dp[i][j] = Math.max(dp[i][j],dp[i-zerounm][j-onenum] +1);
                }
            }
        }
~~~

### code

~~~java
    class Solution {
        public int findMaxForm(String[] strs, int m, int n) {
            int[][] dp = new int[m+1][n+1];

            //遍历物品
            for (String str : strs) {
                int zerounm =0;
                int onenum  =0;
                for (char c : str.toCharArray()) {
                    if (c=='1') onenum++;else zerounm++;
                }

                for (int i = m; i >= zerounm ; i--) {
                    for (int j = n; j >= onenum ; j--) {
                        dp[i][j] = Math.max(dp[i][j],dp[i-zerounm][j-onenum] +1);
                    }
                }
            }

            return dp[m][n];
        }
    }
~~~